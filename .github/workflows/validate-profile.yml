name: Validate Profile Submission

on:
  pull_request_target:
    paths:
      - 'profiles/claude/**'
      - 'profiles/github/**'

permissions:
  pull-requests: write
  issues: write

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Validate profile submission
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const errors = [];
            const warnings = [];

            // Allowed file prefixes per provider
            const ALLOWED_PREFIXES = {
              claude: [
                'CLAUDE.md',
                'commands/',
                'skills/',
                'hooks/',
                'plugins/',
                'mcp.json',
                'mcp_servers/',
                'agents/'
              ],
              github: [
                'copilot-instructions.md',
                'skills/',
                'agents/'
              ]
            };

            // Get changed files in this PR
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });

            const changedPaths = files.map(f => f.filename);

            // Find profile directories being added/modified.
            // Path structure: profiles/<provider>/<author>/<name>/...
            const profilePaths = new Map(); // profileDir -> provider
            for (const p of changedPaths) {
              const match = p.match(/^profiles\/(claude|github)\/([^/]+)\/([^/]+)\//);
              if (match) {
                const profileDir = `profiles/${match[1]}/${match[2]}/${match[3]}`;
                profilePaths.set(profileDir, match[1]);
              }
            }

            if (profilePaths.size === 0) {
              console.log('No profile directories changed, skipping validation.');
              return;
            }

            for (const [profileDir, provider] of profilePaths) {
              const allowedPrefixes = ALLOWED_PREFIXES[provider];
              const metadataPath = `${profileDir}/profile.json`;

              // Check profile.json exists
              if (!fs.existsSync(metadataPath)) {
                errors.push(`Missing profile.json in ${profileDir}`);
                continue;
              }

              // Validate profile.json
              let metadata;
              try {
                metadata = JSON.parse(fs.readFileSync(metadataPath, 'utf-8'));
              } catch (e) {
                errors.push(`Invalid JSON in ${metadataPath}: ${e.message}`);
                continue;
              }

              // Required fields
              if (!metadata.name)    errors.push(`${metadataPath}: missing "name" field`);
              if (!metadata.author)  errors.push(`${metadataPath}: missing "author" field`);
              if (!metadata.version) errors.push(`${metadataPath}: missing "version" field`);

              // Name format
              if (metadata.name && !/^[a-z0-9][a-z0-9-_]*$/.test(metadata.name)) {
                errors.push(`${metadataPath}: invalid name "${metadata.name}" (use lowercase alphanumeric, hyphens, underscores)`);
              }

              // Version format (loose semver)
              if (metadata.version && !/^\d+\.\d+\.\d+/.test(metadata.version)) {
                errors.push(`${metadataPath}: invalid version "${metadata.version}" (use semver: x.y.z)`);
              }

              // Contents check â€” must have at least one functional item
              const contents = metadata.contents || {};
              const hasContent = Object.values(contents).some(
                items => Array.isArray(items) && items.length > 0
              );
              if (!hasContent) {
                const expected = provider === 'github'
                  ? 'skills, agents, or copilot-instructions.md'
                  : 'commands, hooks, skills, agents, etc.';
                errors.push(`${metadataPath}: profile has no functional content (${expected})`);
              }

              // Validate actual changed files against the provider allowlist
              const profileFiles = changedPaths
                .filter(p => p.startsWith(profileDir + '/') && p !== metadataPath)
                .map(p => p.slice(profileDir.length + 1));

              for (const file of profileFiles) {
                const allowed = allowedPrefixes.some(
                  prefix => file === prefix || file.startsWith(prefix)
                );
                if (!allowed) {
                  errors.push(`${profileDir}/${file}: file not allowed for ${provider} profiles (allowed: ${allowedPrefixes.join(', ')})`);
                }
              }

              // Validate files listed in metadata actually exist
              if (metadata.files && metadata.files.length > 0) {
                for (const file of metadata.files) {
                  const normalized = file.replace(/\\/g, '/');
                  const allowed = allowedPrefixes.some(
                    prefix => normalized === prefix || normalized.startsWith(prefix)
                  );
                  if (!allowed) {
                    errors.push(`${metadataPath}: disallowed file path "${file}" in files list`);
                  }
                  const filePath = `${profileDir}/${normalized}`;
                  if (!fs.existsSync(filePath)) {
                    errors.push(`${metadataPath}: file "${file}" listed in metadata but not found in profile directory`);
                  }
                }
              }
            }

            // Validate index.json files if changed
            for (const provider of ['claude', 'github']) {
              const indexPath = `profiles/${provider}/index.json`;
              if (!changedPaths.includes(indexPath)) continue;

              try {
                const index = JSON.parse(fs.readFileSync(indexPath, 'utf-8'));
                if (!Array.isArray(index.profiles)) {
                  errors.push(`${indexPath}: "profiles" must be an array`);
                } else {
                  for (const profile of index.profiles) {
                    if (!profile.name || !profile.author) {
                      errors.push(`${indexPath}: profile entry missing name or author`);
                    }
                    if (!profile.contents || Object.keys(profile.contents).length === 0) {
                      warnings.push(`${indexPath}: profile ${profile.author}/${profile.name} has no contents field`);
                    }
                  }
                }
              } catch (e) {
                errors.push(`${indexPath}: invalid JSON - ${e.message}`);
              }
            }

            // Report results
            if (warnings.length > 0) {
              console.log('Warnings:');
              for (const w of warnings) console.log(`  Warning: ${w}`);
            }

            if (errors.length > 0) {
              console.log('Validation errors:');
              for (const e of errors) console.log(`  Error: ${e}`);

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: [
                  '## Profile Validation Failed',
                  '',
                  ...errors.map(e => `- ${e}`),
                  ...(warnings.length > 0 ? ['', '**Warnings:**', ...warnings.map(w => `- ${w}`)] : []),
                  '',
                  'Please fix these issues and push again.'
                ].join('\n')
              });

              core.setFailed(`Validation failed with ${errors.length} error(s)`);
            } else {
              console.log('All profile validations passed');

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: [
                  '## Profile Validation Passed',
                  '',
                  ...(warnings.length > 0 ? ['**Warnings:**', ...warnings.map(w => `- ${w}`), ''] : []),
                  'Ready for maintainer review.'
                ].join('\n')
              });
            }
